助记符,操作码,操作码（HEX）,指令长度,操作数 i,操作数 j,操作数 k,作用,备注
END,0,0x0,1,-,-,-,程序结束,
NOP,1,0x1,1,-,-,-,空操作,
JMP,2,0x2,3,label,-,-,PC = i;,长跳转
SJMP,3,0x3,2,i8,-,-,PC = PC + i;,短跳转，偏移量
AJMP,4,0x4,2,u8,-,-,PC = (PC & 0xff00) + i;,在地址的256B范围内跳转
SLEEP_X256,5,0x5,2,u8,-,-,Sleep(i * 256);,延时范围0-65280ms（256倍率）
SLEEP,6,0x6,2,u8,-,-,Sleep(i * 1);,延时范围0-255ms
SLEEP_RAND_X256,7,0x7,2,u8,-,-,Sleep(rand()%(i * 256)+1);,随机延时范围1-65281ms（256倍率）
SLEEP_RAND,8,0x8,2,u8,-,-,Sleep(rand()%i+1);,随机延时范围1-256ms
SLEEP_X256_VAL,9,0x9,2,reg,-,-,Sleep(i * 256);,延时的寄存器版本，范围取决于寄存器（256倍率）
SLEEP_VAL,10,0x0A,2,reg,-,-,Sleep(i);,延时的寄存器版本，范围取决于寄存器
SLEEP_RAND_X8_VAL,11,0x0B,2,reg,-,-,Sleep(rand()%(i * 8)+1);,随机延时的寄存器版本，范围取决于寄存器（8倍率）
SLEEP_RAND_VAL,12,0x0C,2,reg,-,-,Sleep(rand()%i+1);,随机延时的寄存器版本，范围取决于寄存器
SLEEP_U16,13,0x0D,3,u16,-,-,Sleep(i);,延时范围1-65536ms
SLEEP_RAND_U16,14,0x0E,3,u16,-,-,Sleep(rand()%i+1);,延时范围1-65536ms
,15,0x0F,1,-,-,-,,
PRESS_SK,16,0x10,2,u8,-,-,键盘 修饰键 i 按下,HID键码
PRESS_GK,17,0x11,2,u8,-,-,键盘 普通键 i 按下,HID键码
PRESS_MK,18,0x12,2,u8,-,-,鼠标 鼠标键 i 按下,HID键码
PRESS_MU,19,0x13,2,u8,-,-,按键 多媒体 i 按下,HID键码
PRESS_SK_VAL,20,0x14,2,reg,-,-,键盘 修饰键 i 按下,HID键码
PRESS_GK_VAL,21,0x15,2,reg,-,-,键盘 普通键 i 按下,HID键码
PRESS_MK_VAL,22,0x16,2,reg,-,-,鼠标 鼠标键 i 按下,HID键码
PRESS_MU_VAL,23,0x17,2,reg,-,-,按键 多媒体 i 按下,HID键码
RELEASE_SK,24,0x18,2,u8,-,-,键盘 修饰键 i 释放,HID键码
RELEASE_GK,25,0x19,2,u8,-,-,键盘 普通键 i 释放,HID键码
RELEASE_MK,26,0x1A,2,u8,-,-,鼠标 鼠标键 i 释放,HID键码
RELEASE_MU,27,0x1B,2,u8,-,-,按键 多媒体 i 释放,HID键码
RELEASE_SK_VAL,28,0x1C,2,reg,-,-,键盘 修饰键 i 释放,HID键码
RELEASE_GK_VAL,29,0x1D,2,reg,-,-,键盘 普通键 i 释放,HID键码
RELEASE_MK_VAL,30,0x1E,2,reg,-,-,鼠标 鼠标键 i 释放,HID键码
RELEASE_MU_VAL,31,0x1F,2,reg,-,-,按键 多媒体 i 释放,HID键码
UPDATE,32,0x20,1,-,-,-,HID数据包强制重传(一般不会使用),
MO_XYZ,33,0x21,3,u8,i8,-,鼠标 光标移动 axis=i data=j,"0: x, 1:y, 2:scroll"
MO_XYZ_VAL,34,0x22,3,u8,reg,-,鼠标 光标移动 axis=i data=j,
GA_XYZ,35,0x23,4,u8,u16,-,joystick axis=i data=j,
GA_XYZ_VAL,36,0x24,3,u8,reg,-,joystick axis=i data=j,
TB_XY,37,0x25,5,i16,i16,-,鼠标 光标定位 x=i y=j,
TB_XY_VAL,38,0x26,3,reg,reg,-,鼠标 光标定位 x=i y=j,
DIAL_DATA,39,0x27,2,u8,-,-,Dial data=i,data:0=release 1=press 2=cw 3=ccw
DIAL_DATA_VAL,40,0x28,2,reg,-,-,Dial data=i,data:0=release 1=press 2=cw 3=ccw
KEY_TO_AXIS,41,0x29,1,-,-,-,joystick axis=reg::val[0] type=reg::val[1],内部使用
,42,0x2A,1,-,-,-,,
,43,0x2B,1,-,-,-,,
PRESS_GAK,44,0x2C,2,u8,-,-,joystick 按键 i 按下,
PRESS_GAK_VAL,45,0x2D,2,reg,-,-,joystick 按键 i 按下,
RELEASE_GAK,46,0x2E,2,u8,-,-,joystick 按键 i 释放,
RELEASE_GAK_VAL,47,0x2F,2,reg,-,-,joystick 按键 i 释放,
C2K,48,0x30,1,-,-,-,print ascii character,内部使用
U2K,49,0x31,1,-,-,-,print unicode character,内部使用
C2K_RAND,50,0x32,1,-,-,-,print random ascii character,内部使用
U2K_REG,51,0x33,1,-,-,-,print value,内部使用，需要循环调用直到输出完毕
PRINT_REG,52,0x34,2,reg,-,-,print value,打印寄存器值，只需要执行一次即可完整输出
,53,0x35,1,-,-,-,,
,54,0x36,1,-,-,-,,
,55,0x37,1,-,-,-,,
,56,0x38,1,-,-,-,,
,57,0x39,1,-,-,-,,
,58,0x3A,1,-,-,-,,
,59,0x3B,1,-,-,-,,
,60,0x3C,1,-,-,-,,
,61,0x3D,1,-,-,-,,
,62,0x3E,1,-,-,-,,
,63,0x3F,1,-,-,-,,
JFA,64,0x40,4,reg,reg,reg,if (i>j)PC=k;,比较两个寄存器的值(无符号数)，根据结果判断是否跳转，目标地址存储于寄存器
JFB,65,0x41,4,reg,reg,reg,if (i<j)PC=k;,比较两个寄存器的值(无符号数)，根据结果判断是否跳转，目标地址存储于寄存器
JFG,66,0x42,4,reg,reg,reg,if (i>j)PC=k;,比较两个寄存器的值(无符号数)，根据结果判断是否跳转，目标地址存储于寄存器
JFL,67,0x43,4,reg,reg,reg,if (i<j)PC=k;,比较两个寄存器的值(无符号数)，根据结果判断是否跳转，目标地址存储于寄存器
JA,68,0x44,5,reg,reg,label,if (i>j)PC=k;,比较两个寄存器的值(有符号数)，根据结果判断是否跳转，目标地址为label
JB,69,0x45,5,reg,reg,label,if (i<j)PC=k;,比较两个寄存器的值(有符号数)，根据结果判断是否跳转，目标地址为label
JG,70,0x46,5,reg,reg,label,if (i>j)PC=k;,比较两个寄存器的值(有符号数)，根据结果判断是否跳转，目标地址为label
JL,71,0x47,5,reg,reg,label,if (i<j)PC=k;,比较两个寄存器的值(有符号数)，根据结果判断是否跳转，目标地址为label
JFC,72,0x48,2,reg,-,-,if (CY) PC = i;,如果CY置位，则跳转。目标地址存储于寄存器
JFNC,73,0x49,2,reg,-,-,if (!CY) PC = i;,如果CY没有置位，则跳转。目标地址存储于寄存器
JFZ,74,0x4A,3,reg,reg,-,if (!i) PC = j;,寄存器为0跳转。目标地址存储于寄存器
JFNZ,75,0x4B,3,reg,-,-,if (i) PC = j;,寄存器不为0跳转。目标地址存储于寄存器
DJFNZ,76,0x4C,3,reg,reg,-,if (--i) PC = j;,寄存器减1并存回，寄存器不为0跳转。目标地址存储于寄存器
CJFNE,77,0x4D,4,reg,reg,reg,if (i != j) {CY = i<j;PC = k},比较两个寄存器并设置CY标识，不相等则跳转。目标地址存储于寄存器
JC,78,0x4E,3,label,-,-,if (CY) PC = i;,如果CY置位，则跳转。目标地址为label
JNC,79,0x4F,3,label,-,-,if (!CY) PC = i;,如果CY没有置位，则跳转。目标地址为label
JZ,80,0x50,4,reg,label,-,if (!i) PC = j;,寄存器为0跳转。目标地址为label
JNZ,81,0x51,4,reg,label,-,if (i) PC = j;,寄存器不为0跳转。目标地址为label
DJNZ,82,0x52,4,reg,label,-,if (--i) PC = j;,寄存器减1并存回，寄存器不为0跳转。目标地址为label
CJNE,83,0x53,5,reg,reg,label,if (i != j) {CY = i<j;PC = k},比较两个寄存器并设置CY标识，不相等则跳转。目标地址为label
CALL,84,0x54,3,label,-,-,PUSH PC;PC=i;,调用子程序，目标地址为label
RET,85,0x55,1,-,-,-,POP PC;,子程序返回
AND,86,0x56,3,reg,reg,-,i=i&j;,
AND8,87,0x57,3,reg,u8,-,i=i&j;,
ADD_A,88,0x58,2,reg,-,-,A = A + i;,
ADD8_A,89,0x59,2,u8,-,-,A = A + i;,
SUB_A,90,0x5A,2,reg,-,-,A = A - i;,
SUB8_A,91,0x5B,2,u8,-,-,A = A - i;,
OR_A,92,0x5C,2,reg,-,-,A = A | i;,
OR8_A,93,0x5D,2,u8,-,-,A = A | i;,
DEC,94,0x5E,2,reg,-,-,i--;,
INC,95,0x5F,2,reg,-,-,i++;,
MUL_A,96,0x60,1,-,-,-,A = A * B;,
DIV_A,97,0x61,1,-,-,-,A = A / B;B = A % B;,
XOR,98,0x62,3,reg,reg,-,i=i^j;,
XOR8,99,0x63,3,reg,u8,-,i=i^j;,
SHL,100,0x64,3,reg,reg,-,i=i<<j;,
SHL8,101,0x65,3,reg,u8,-,i=i<<j;,
SHR,102,0x66,3,reg,reg,-,i=i>>j;,
SHR8,103,0x67,3,reg,u8,-,i=i>>j;,
CLR,104,0x68,2,reg,-,-,i=0;,寄存器清理
NOT,105,0x69,2,reg,-,-,i=~i;,寄存器按位取反
XCH,106,0x6A,3,reg,reg,-,i<==>j;,ij交换
CMP,107,0x6B,3,reg,reg,-,CY=i<j;,比较两个寄存器并设置CY标识（目前本指令没有的必要）
PUSH,108,0x6C,2,reg,-,-,,压栈
POP,109,0x6D,2,reg,-,-,,出栈
MOV,110,0x6E,3,reg,reg,-,i=j;,
MOV8,111,0x6F,3,reg,u8,-,i=j;,
MOV16,112,0x70,4,reg,u16,-,i=j;,
MOV32,113,0x71,6,reg,u32,-,i=j;,
ADD,114,0x72,3,reg,reg,-,i=i+j;,
ADD8,115,0x73,3,reg,u8,-,i=i+j;,
ADD16,116,0x74,4,reg,u16,-,i=i+j;,
SUB,117,0x75,3,reg,reg,-,i=i-j;,
SUB8,118,0x76,3,reg,u8,-,i=i-j;,
SUB16,119,0x77,4,reg,u16,-,i=i-j;,
OR,120,0x78,3,reg,reg,-,i=i|j;,
OR8,121,0x79,3,reg,u8,-,i=i|j;,
AND16,122,0x7A,4,reg,u16,-,i=i&j;,
OR16,123,0x7B,4,reg,u16,-,i=i|j;,
XOR16,124,0x7C,4,reg,u16,-,i=i^j;,
ADD32,125,0x7D,6,reg,u32,-,i=i+j;,
SUB32,126,0x7E,6,reg,u32,-,i=i-j;,
AND32,127,0x7F,6,reg,u32,-,i=i&j;,
OR32,128,0x80,6,reg,u32,-,i=i|j;,
XOR32,129,0x81,6,reg,u32,-,i=i^j;,
ADD_R,130,0x82,4,reg,reg,reg,i=j+k;,
SUB_R,131,0x83,4,reg,reg,reg,i=j-k;,
AND_R,132,0x84,4,reg,reg,reg,i=j&k;,
OR_R,133,0x85,4,reg,reg,reg,i=j|k;,
XOR_R,134,0x86,4,reg,reg,reg,i=j^k;,
MUL_R,135,0x87,4,reg,reg,reg,i=j*k;,
DIV_R,136,0x88,4,reg,reg,reg,i=j/k;,
MOD_R,137,0x89,4,reg,reg,reg,i=j%k;,
MOVSX8b,138,0x8A,3,reg,reg,-,i=j;,
MOVSX16b,139,0x8B,3,reg,reg,-,i=j;,
MOV8SX,140,0x8C,3,reg,i8,-,i=j;,
MOV16SX,141,0x8D,4,reg,i16,-,i=j;,
IMUL_A,142,0x8E,1,-,-,-,A=A*B;,
IMUL_R,143,0x8F,4,reg,reg,reg,i=j*k;,
,144,0x90,1,-,-,-,,
,145,0x91,1,-,-,-,,
,146,0x92,1,-,-,-,,
,147,0x93,1,-,-,-,,
,148,0x94,1,-,-,-,,
,149,0x95,1,-,-,-,,
,150,0x96,1,-,-,-,,
,151,0x97,1,-,-,-,,
,152,0x98,1,-,-,-,,
,153,0x99,1,-,-,-,,
,154,0x9A,1,-,-,-,,
,155,0x9B,1,-,-,-,,
,156,0x9C,1,-,-,-,,
,157,0x9D,1,-,-,-,,
,158,0x9E,1,-,-,-,,
,159,0x9F,1,-,-,-,,
,160,,1,-,-,-,,
,161,,1,-,-,-,,
,162,,1,-,-,-,,
,163,,1,-,-,-,,
,164,,1,-,-,-,,
,165,,1,-,-,-,,
,166,,1,-,-,-,,
,167,,1,-,-,-,,
,168,,1,-,-,-,,
,169,,1,-,-,-,,
,170,,1,-,-,-,,
,171,,1,-,-,-,,
,172,,1,-,-,-,,
,173,,1,-,-,-,,
,174,,1,-,-,-,,
,175,,1,-,-,-,,
,176,,1,-,-,-,,
,177,,1,-,-,-,,
,178,,1,-,-,-,,
,179,,1,-,-,-,,
,180,,1,-,-,-,,
,181,,1,-,-,-,,
,182,,1,-,-,-,,
,183,,1,-,-,-,,
,184,,1,-,-,-,,
,185,,1,-,-,-,,
,186,,1,-,-,-,,
,187,,1,-,-,-,,
,188,,1,-,-,-,,
,189,,1,-,-,-,,
,190,,1,-,-,-,,
,191,,1,-,-,-,,
,192,,1,-,-,-,,
,193,,1,-,-,-,,
,194,,1,-,-,-,,
,195,,1,-,-,-,,
,196,,1,-,-,-,,
,197,,1,-,-,-,,
,198,,1,-,-,-,,
,199,,1,-,-,-,,
,200,,1,-,-,-,,
,201,,1,-,-,-,,
,202,,1,-,-,-,,
,203,,1,-,-,-,,
,204,,1,-,-,-,,
,205,,1,-,-,-,,
,206,,1,-,-,-,,
,207,,1,-,-,-,,
,208,,1,-,-,-,,
,209,,1,-,-,-,,
,210,,1,-,-,-,,
,211,,1,-,-,-,,
,212,,1,-,-,-,,
,213,,1,-,-,-,,
,214,,1,-,-,-,,
,215,,1,-,-,-,,
,216,,1,-,-,-,,
,217,,1,-,-,-,,
,218,,1,-,-,-,,
,219,,1,-,-,-,,
,220,,1,-,-,-,,
,221,,1,-,-,-,,
,222,,1,-,-,-,,
,223,,1,-,-,-,,
LED_CTRL,224,0xE0,2,u8,-,-,SELECTED_LED = i;,0xff = release
LED_COL,225,0xE1,4,RGB888,-,-,SELECTED_LED_COL = i;,
START,226,0xE2,2,u8,-,-,Start_key(i-1);,0=all
STOP,227,0xE3,2,u8,-,-,Stop_key(i-1);,0=all
,228,0xE4,1,-,-,-,,
,229,0xE5,1,-,-,-,,
,230,0xE6,1,-,-,-,,
,231,0xE7,1,-,-,-,,
SYCON,232,0xE8,2,u8,-,-,,系统控制
,233,0xE9,1,-,-,-,,
,234,,1,-,-,-,,
,235,,1,-,-,-,,
,236,,1,-,-,-,,
,237,,1,-,-,-,,
,238,,1,-,-,-,,
,239,,1,-,-,-,,
MALLOC,240,0xF0,2,reg,-,-,i=malloc(i);,
FREE,241,0xF1,2,reg,-,-,i=free(i);,
NEW_THREAD,242,0xF2,4,u8,reg,reg,i=TH ID;j=addr or keymode;k=V[4],i的取值范围0~3，实际占用寄存器R12-R15暂存线程地址；主线程退出子线程也会被强制退出；子线程退出不会自动释放malloc内存，除非主线程退出；子线程里可以继续开子线程，但是不建议套太多层
,243,0xF3,1,-,-,-,,
WHILE_UPDATE,244,0xF4,1,-,-,-,while (update_flag)Sleep(1);,等待HID上传数据完成
JMP_TO_SCRIPT,245,0xF5,2,u8,-,-,,跳转到其他脚本号（寄存器数据保留，但PC会重置）
MOV_PC2REG,246,0xF6,2,reg,-,-,i=PC;,把下一条指令的地址保存到寄存器
VALUE_RELOAD,247,0xF7,2,reg,-,-,i=Reload(reg);,重新加载脚本参数
MODE_JOG,248,0xF8,1,-,-,-,,进入点动模式（再次按下按键不会被强制打断）
WAIT_IF_RELEASE,249,0xF9,1,-,-,-,while (IO) Sleep(1);,如果物理按键是释放状态，等待按下后才会继续执行
WAIT_IF_PRESS,250,0xFA,1,-,-,-,while (!IO) Sleep(1);,如果物理按键是按下状态，等待释放后才会继续执行
EXIT_IF_RELEAS,251,0xFB,1,-,-,-,if (IO) exit();,如果物理按键是释放的，退出脚本
EXIT_IF_PRESS,252,0xFC,1,-,-,-,if (!IO) exit();,如果物理按键是按下的，退出脚本
EXIT_IF_ANYKEY,253,0xFD,1,-,-,-,if (SYS_KEY_COUNT != n) exit();,n=脚本开始执行时保存的按键计数器。脚本执行后，可以用此指令实现按任意键退出
RES,254,0xFE,1,-,-,-,PC = 0;,跳转到程序开头，等同于JMP 0
EXIT,255,0xFF,1,-,-,-,exit();,退出脚本
